<!DOCTYPE html>
<!-- saved from url=(0113)https://ecs.syr.edu/faculty/fawcett/handouts/CSE687/code/Project2HelpS2019/OodProject2Helper/Proj2Helper.cpp.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <style>
    body {
      padding: 15px 40px;
      font-family: Consolas;
      font-size: 1.25em;
      font-weight: normal;
    }

    span {
      display: inline;
    }

    #funcButton {
      position: fixed;
      bottom: 50px;
      right: 50px;
    }
	
	#classButton {
		position: fixed;
      bottom: 70px;
      right: 50px;
	}
	
	#commentButton {
		position: fixed;
      bottom: 90px;
      right: 50px;
	}
	
    .toggleClassDisplay {
    }

    .toggleMethodDisplay {
    }
	
	.toggleCommentDisplay {
    }
  </style>
  <script>
      function showHideClass(className) {
        let elems = document.getElementsByClassName(className);
        if (elems === null) {
          return;
        }
        for (let i = 0; i < elems.length; ++i) {
          let displayProp = elems[i].style.display;
          if (displayProp === 'none')
            elems[i].style['display'] = "inline";
          else
            elems[i].style['display'] = "none";
        }
      }
  </script>
</head>
<body>
<h3>Tokenizer.cpp</h3>
  <button onclick="showHideClass(&#39;toggleMethodDisplay&#39;)" id="funcButton">Show or Hide Method Contents</button>
  <button onclick="showHideClass(&#39;toggleClassDisplay&#39;)" id="classButton">Show or Hide Class Contents</button>
  <button onclick="showHideClass(&#39;toggleCommentDisplay&#39;)" id="commentButton">Show or Hide Comment Contents</button>
<pre>
<pre>
<a href="../ConvertedPages/Tokenizer.h.html">"Tokenizer.h"</a>
<a href="../ConvertedPages/Utilities.h.html">Utilities.h"</a>
<span class = "toggleCommentDisplay">/////////////////////////////////////////////////////////////////////</span>
<span class = "toggleCommentDisplay">// Tokenizer.cpp - read words from a std::stream                   //</span>
<span class = "toggleCommentDisplay">// ver 4.2                                                         //</span>
<span class = "toggleCommentDisplay">// Language:    C++, Visual Studio 2015                            //</span>
<span class = "toggleCommentDisplay">// Platform:    Dell XPS 8900, Windows 10                          //</span>
<span class = "toggleCommentDisplay">// Application: Parser component, CSE687 - Object Oriented Design  //</span>
<span class = "toggleCommentDisplay">// Author:      Jim Fawcett, Syracuse University, CST 4-187        //</span>
<span class = "toggleCommentDisplay">//              jfawcett@twcny.rr.com                              //</span>
<span class = "toggleCommentDisplay">/////////////////////////////////////////////////////////////////////</span>

#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include "Tokenizer.h"
#include "..\Utilities\Utilities.h"

namespace Scanner
{
  <span class = "toggleCommentDisplay">///////////////////////////////////////////////////////////////////</span>
  <span class = "toggleCommentDisplay">// Context is a shared data storage facility.</span>
  <span class = "toggleCommentDisplay">/*
   * - with Context we don't need static members to share
   *   state pointes etc.  Context holds and shares all that.
   * - Context is an entirely private facility used by ConsumeState
   *   and its derived instances, so there is no need for encapsulation
   *   and we use a struct.  This won't be appropriate if we handed
   *   the context to clients of Toker.
   */</span>
  struct Context
  {
    Context();
    ~Context();
    std::string token;
    std::istream* _pIn;
    std::vector&lt;std::string&gt; _oneCharTokens =
    {
      "\n", "&lt;", "&gt;", "{", "}", "[", "]", "(", ")", ":", ";", " = ", " + ", " - ", "*", ".", ",", "@"
    };
    std::vector&lt;std::string&gt; _twoCharTokens =
    {
      "&lt;&lt;", "&gt;&gt;", "::", "++", "--", "==", "+=", "-=", "*=", "/="
    };
    int prevChar;
    int currChar;
    bool _doReturnComments;
    bool inCSharpString = false;
    size_t _lineCount;
    ConsumeState* _pState;
    ConsumeState* _pEatCppComment;
    ConsumeState* _pEatCComment;
    ConsumeState* _pEatWhitespace;
    ConsumeState* _pEatPunctuator;
    ConsumeState* _pEatAlphanum;
    ConsumeState* _pEatSpecialCharacters;
    ConsumeState* _pEatDQString;
    ConsumeState* _pEatSQString;
    ConsumeState* _pEatRawCppString;
    ConsumeState* _pEatRawCSharpString;
  };

  <span class = "toggleCommentDisplay">///////////////////////////////////////////////////////////////////</span>
  <span class = "toggleCommentDisplay">// private ConsumeState worker class</span>
  <span class = "toggleCommentDisplay">/*
   *   Nota Bene:
   *   - At exit the eatChars() member should return with
   *     currChar set to the first non-state character.
   *   - Each derived class must insure that this condition
   *     is meet.
   */</span>
  class ConsumeState
  <span class = "toggleClassDisplay">{
    friend class Toker;
  public:
    using Token = std::string;
    ConsumeState();
    ConsumeState(const ConsumeState&) = delete;
    ConsumeState& operator=(const ConsumeState&) = delete;
    virtual ~ConsumeState();
    void attach(std::istream* pIn);
    virtual void eatChars() = 0;
    void consumeChars() {
      _pContext-&gt;_pState-&gt;eatChars();
      _pContext-&gt;_pState = nextState();
    }
    bool canRead() { return _pContext-&gt;_pIn-&gt;good(); }
    std::string getTok() { return _pContext-&gt;token; }
    bool hasTok() { return _pContext-&gt;token.size() &gt; 0; }
    ConsumeState* nextState();
    void returnComments(bool doReturnComments = false);
    size_t currentLineCount();
    void setSpecialTokens(const std::string& commaSeparatedString);
    void setContext(Context* pContext);
  protected:
    Context* _pContext;
    bool collectChar();
    bool isOneCharToken(Token tok);
    bool isTwoCharToken(Token tok);
    Token makeString(int ch);
  };</span>
}

using namespace Scanner;
using Token = std::string;

<span class = "toggleCommentDisplay">//----&lt; used by Toker to provide Consumer with Context ptr &gt;---------</span>

void ConsumeState::setContext(Context* pContext)
{
  _pContext = pContext;
}
<span class = "toggleCommentDisplay">//----&lt; attach or re-attach to input stream &gt;------------------------</span>

void ConsumeState::attach(std::istream* pIn)
{
  _pContext-&gt;_pState = _pContext-&gt;_pEatWhitespace;
  _pContext-&gt;_lineCount = 0;
  _pContext-&gt;_pIn = pIn;
}
<span class = "toggleCommentDisplay">//----&lt; replace one and two char tokens &gt;----------------------------</span>

void ConsumeState::setSpecialTokens(const std::string& commaSeparatedTokens)
{
  std::vector&lt;Token&gt; result = Utilities::StringHelper::split(commaSeparatedTokens);
  _pContext-&gt;_oneCharTokens.clear();
  _pContext-&gt;_twoCharTokens.clear();
  for (std::string item : result)
  {
    if (item.size() == 1 || item == "\n")
      _pContext-&gt;_oneCharTokens.push_back(item);
    if (item.size() &gt;= 2)
      _pContext-&gt;_twoCharTokens.push_back(item);
  }
}
<span class = "toggleCommentDisplay">//----&lt; return number of newlines collected from stream &gt;------------</span>

size_t ConsumeState::currentLineCount() { return _pContext-&gt;_lineCount; }

<span class = "toggleCommentDisplay">//----&lt; collect character from stream &gt;------------------------------</span>

bool ConsumeState::collectChar()
{
  if (_pContext-&gt;_pIn-&gt;good())
  {
    _pContext-&gt;prevChar = _pContext-&gt;currChar;
    _pContext-&gt;currChar = _pContext-&gt;_pIn-&gt;get();
    if (_pContext-&gt;currChar == '\n')
      ++(_pContext-&gt;_lineCount);
    return true;
  }
  return false;
}

<span class = "toggleCommentDisplay">//----&lt; logs to console if TEST_LOG is defined &gt;---------------------</span>

void testLog(const std::string& msg);  <span class = "toggleCommentDisplay">// forward declaration</span>

<span class = "toggleCommentDisplay">//----&lt; turn on\off returning comments as tokens &gt;-------------------</span>

void ConsumeState::returnComments(bool doReturnComments)
{
  _pContext-&gt;_doReturnComments = doReturnComments;
}
<span class = "toggleCommentDisplay">//----&lt; is tok one of the special one character tokens? &gt;------------</span>

bool ConsumeState::isOneCharToken(Token tok)
{
  for (size_t i = 0; i &lt; _pContext-&gt;_oneCharTokens.size(); ++i)
    if (_pContext-&gt;_oneCharTokens[i] == tok)
      return true;
  return false;
}
<span class = "toggleCommentDisplay">//----&lt; is tok one of the special two character tokens? &gt;------------</span>

bool ConsumeState::isTwoCharToken(Token tok)
{
  for (size_t i = 0; i &lt; _pContext-&gt;_twoCharTokens.size(); ++i)
    if (_pContext-&gt;_twoCharTokens[i] == tok)
      return true;
  return false;
}
<span class = "toggleCommentDisplay">//----&lt; make a string with this one integer &gt;------------------------</span>

ConsumeState::Token ConsumeState::makeString(int ch)
{
  Token temp;
  return temp += ch;
}
<span class = "toggleCommentDisplay">//----&lt; decide which state to use next &gt;-----------------------------</span>

ConsumeState* ConsumeState::nextState()
{
  std::locale loc;

  if (!(_pContext-&gt;_pIn-&gt;good()))
  {
    return nullptr;
  }
  int chNext = _pContext-&gt;_pIn-&gt;peek();
  if (chNext == EOF)
  {
    _pContext-&gt;_pIn-&gt;clear();
    <span class = "toggleCommentDisplay">// if peek() reads end of file character, EOF, then eofbit is set and</span>
    <span class = "toggleCommentDisplay">// _pIn-&gt;good() will return false.  clear() restores state to good</span>
  }
  <span class = "toggleCommentDisplay">//---------------------------------------------------------</span>
  <span class = "toggleCommentDisplay">// The following tests must come first</span>

  if (_pContext-&gt;currChar == '\"' && _pContext-&gt;prevChar != '\\')
  {
    testLog("state: eatDQString");
    return _pContext-&gt;_pEatDQString;
  }
  if (_pContext-&gt;currChar == '\'' && _pContext-&gt;prevChar != '\\')
  {
    testLog("state: eatSQString");
    return _pContext-&gt;_pEatSQString;
  }
  if (_pContext-&gt;currChar == '/' && chNext == '/')
  {
    testLog("state: eatCppComment");
    return _pContext-&gt;_pEatCppComment;
  }
  if (_pContext-&gt;currChar == '/' && chNext == '*')
  {
    testLog("state: eatCComment");
    return _pContext-&gt;_pEatCComment;
  }
  if (_pContext-&gt;currChar == 'R' && chNext == '\"')
  {
    testLog("state: eatRawCppString");
    return _pContext-&gt;_pEatRawCppString;
  }
  if (_pContext-&gt;currChar == '@' && chNext == '\"')
  {
    testLog("state: eatRawCSharpString");
    return _pContext-&gt;_pEatRawCSharpString;
  }
  <span class = "toggleCommentDisplay">//---------------------------------------------------------</span>
  <span class = "toggleCommentDisplay">// The following tests must come after those above</span>

  if (isOneCharToken(makeString(_pContext-&gt;currChar)))
  {
    testLog("state: eatSpecialCharacters");
    return _pContext-&gt;_pEatSpecialCharacters;
  }
  if (std::isspace(_pContext-&gt;currChar, loc) && _pContext-&gt;currChar != '\n')
  {
    testLog("state: eatWhitespace");
    return _pContext-&gt;_pEatWhitespace;
  }
  if (std::isalnum(_pContext-&gt;currChar, loc) || _pContext-&gt;currChar == '_')
  {
    testLog("state: eatAlphanum");
    return _pContext-&gt;_pEatAlphanum;
  }
  if (ispunct(_pContext-&gt;currChar))
  {
    testLog("state: eatPunctuator");
    return _pContext-&gt;_pEatPunctuator;
  }
  if (!_pContext-&gt;_pIn-&gt;good())
  {
    testLog("state: eatWhitespace");
    return _pContext-&gt;_pEatWhitespace;
  }
  <span class = "toggleCommentDisplay">//---------------------------------------------------------</span>
  <span class = "toggleCommentDisplay">// If _pContext-&gt;currChar is not a state transition char</span>
  <span class = "toggleCommentDisplay">// then we go to eatPuctuator state</span>

  return _pContext-&gt;_pEatPunctuator;
}
<span class = "toggleCommentDisplay">//----&lt; class that consumes whitespace &gt;-----------------------------</span>

class EatWhitespace : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatWhitespace(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    std::locale loc;
    _pContext-&gt;token.clear();
    do {
      if (!collectChar())
        return;
    } while (std::isspace(_pContext-&gt;currChar, loc) && _pContext-&gt;currChar != '\n');
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that consumes C++ comment &gt;----------------------------</span>

class EatCppComment : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatCppComment(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    do {
      if (_pContext-&gt;_doReturnComments)
        _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (_pContext-&gt;currChar != '\n');
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that consumes C comment &gt;------------------------------</span>

class EatCComment : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatCComment(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    do {
      if (_pContext-&gt;_doReturnComments)
        _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (_pContext-&gt;currChar != '*' || _pContext-&gt;_pIn-&gt;peek() != '/');
    if (_pContext-&gt;_doReturnComments)
      _pContext-&gt;token += _pContext-&gt;currChar;
    if (!collectChar())      <span class = "toggleCommentDisplay">// get terminating '/'</span>
      return;
    if (_pContext-&gt;_doReturnComments)
      _pContext-&gt;token += _pContext-&gt;currChar;
    collectChar();           <span class = "toggleCommentDisplay">// get first non-comment char</span>
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats punctuators &gt;--------------------------------</span>

class EatPunctuator : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatPunctuator(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    int chNext = _pContext-&gt;_pIn-&gt;peek();
    do {
      if (_pContext-&gt;currChar == '\"' && _pContext-&gt;prevChar != '\\')    <span class = "toggleCommentDisplay">// start of double quoted string</span>
      {
        return;
      }
      if (_pContext-&gt;currChar == '@' && chNext == '\"')    <span class = "toggleCommentDisplay">// start of raw C# double quoted string</span>
      {
        return;
      }
      if (_pContext-&gt;currChar == '\'' && _pContext-&gt;prevChar != '\\')    <span class = "toggleCommentDisplay">// start of single quoted string</span>
      {
        return;
      }
      Token temp = makeString(_pContext-&gt;currChar);
      if (isOneCharToken(temp))
      {
        return;
      }
      _pContext-&gt;token += _pContext-&gt;currChar;
      if (!_pContext-&gt;_pIn-&gt;good())  <span class = "toggleCommentDisplay">// end of stream</span>
      {
        return;
      }
      if (!collectChar())
        return;
    } while (ispunct(_pContext-&gt;currChar));
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats alphanumeric characters &gt;--------------------</span>
<span class = "toggleCommentDisplay">/*
 * treats underscore '_' as alphanumeric character
 */</span>
class EatAlphanum : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatAlphanum(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    int chNext = _pContext-&gt;_pIn-&gt;peek();
    do {
      _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (isalnum(_pContext-&gt;currChar) || _pContext-&gt;currChar == '_');
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats one and two character tokens &gt;---------------</span>

class EatSpecialCharacters : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatSpecialCharacters(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    _pContext-&gt;token += _pContext-&gt;currChar;
    Token temp = makeString(_pContext-&gt;currChar) += _pContext-&gt;_pIn-&gt;peek();
    if (isTwoCharToken(temp))
    {
      collectChar();
      _pContext-&gt;token += _pContext-&gt;currChar;
    }
    collectChar();
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats double quoted string &gt;-----------------------</span>

bool isEscapted(std::string tok)
{
  size_t backSlashCount = 0;
  for (size_t i = tok.size() - 1; i &gt;= 0; --i)
  {
    if (tok[i] == '\\')
      ++backSlashCount;
    else break;
  }
  return (backSlashCount % 2 == 1);
}
<span class = "toggleCommentDisplay">//----&lt; class that eats double quoted string &gt;-----------------------</span>

class EatDQString : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatDQString(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    do
    {
      _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (_pContext-&gt;currChar != '\"' || isEscapted(_pContext-&gt;token));
    _pContext-&gt;token += _pContext-&gt;currChar;
    _pContext-&gt;inCSharpString = false;
    collectChar();
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats double quoted string &gt;-----------------------</span>

class EatRawCppString : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatRawCppString(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    do
    {
      _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (_pContext-&gt;currChar != '\"' || _pContext-&gt;prevChar == 'R');
    _pContext-&gt;token += _pContext-&gt;currChar;
    collectChar();
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats double quoted string &gt;-----------------------</span>

class EatRawCSharpString : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatRawCSharpString(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    do
    {
      _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (_pContext-&gt;currChar != '\"' || _pContext-&gt;prevChar == '@');
    _pContext-&gt;token += _pContext-&gt;currChar;
    collectChar();
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; class that eats single quoted string &gt;-----------------------</span>

class EatSQString : public ConsumeState
<span class = "toggleClassDisplay">{
public:
  EatSQString(Context* pContext)
  {
    _pContext = pContext;
  }
  virtual void eatChars()
  {
    _pContext-&gt;token.clear();
    do
    {
      _pContext-&gt;token += _pContext-&gt;currChar;
      if (!collectChar())
        return;
    } while (_pContext-&gt;currChar != '\'' || isEscapted(_pContext-&gt;token));
    _pContext-&gt;token += _pContext-&gt;currChar;
    collectChar();
  }
};</span>
<span class = "toggleCommentDisplay">//----&lt; construct shared data storage &gt;------------------------------</span>

Context::Context()
<span class = "toggleMethodDisplay">{
  _pEatAlphanum = new EatAlphanum(this);
  _pEatCComment = new EatCComment(this);
  _pEatCppComment = new EatCppComment(this);
  _pEatPunctuator = new EatPunctuator(this);
  _pEatWhitespace = new EatWhitespace(this);
  _pEatSpecialCharacters = new EatSpecialCharacters(this);
  _pEatDQString = new EatDQString(this);
  _pEatRawCppString = new EatRawCppString(this);
  _pEatRawCSharpString = new EatRawCSharpString(this);
  _pEatSQString = new EatSQString(this);
  _pState = _pEatWhitespace;
  _lineCount = 0;
  _doReturnComments = false;
}</span>
<span class = "toggleCommentDisplay">//----&lt; return shared resources &gt;------------------------------------</span>

Context::~Context()
<span class = "toggleMethodDisplay">{
  delete _pEatAlphanum;
  delete _pEatCComment;
  delete _pEatCppComment;
  delete _pEatPunctuator;
  delete _pEatWhitespace;
  delete _pEatSpecialCharacters;
  delete _pEatDQString;
  delete _pEatRawCppString;
  delete _pEatRawCSharpString;
  delete _pEatSQString;
}</span>
<span class = "toggleCommentDisplay">//----&lt; no longer has anything to do - will be removed &gt;-------------</span>

ConsumeState::ConsumeState() {}

<span class = "toggleCommentDisplay">//----&lt; no longer has anything to do - will be removed &gt;-------------</span>

ConsumeState::~ConsumeState() {}

<span class = "toggleCommentDisplay">//----&lt; construct toker starting in state EatWhitespace &gt;------------</span>

Toker::Toker()
{
  _pContext = new Context();
  pConsumer = _pContext-&gt;_pEatWhitespace;
  pConsumer-&gt;setContext(_pContext);
}

<span class = "toggleCommentDisplay">//----&lt; destructor deletes the current state &gt;-----------------------</span>
<span class = "toggleCommentDisplay">/*
 * deleting any state deletes them all since derived destructor
 * implicitly invokes the base destructor
 */</span>
Toker::~Toker() 
{
  delete _pContext;
  _pContext = nullptr;
}

<span class = "toggleCommentDisplay">//----&lt; attach tokenizer to stream &gt;---------------------------------</span>
<span class = "toggleCommentDisplay">/*
 * stream can be either a std::fstream or std::stringstream
 */</span>
bool Toker::attach(std::istream* pIn)
{
  if (pIn != nullptr && pIn-&gt;good())
  {
    pConsumer-&gt;attach(pIn);
    <span class = "toggleCommentDisplay">//_pContext-&gt;_pIn = pIn;</span>
    return true;
  }
  return false;
}
<span class = "toggleCommentDisplay">//----&lt; collect token generated by ConsumeState &gt;--------------------</span>

std::string Toker::getTok()
{
  while(true) 
  {
    if (!pConsumer-&gt;canRead())
      return "";
    pConsumer-&gt;consumeChars();
    if (pConsumer-&gt;hasTok())
      break;
  }
  return pConsumer-&gt;getTok();
}
<span class = "toggleCommentDisplay">//----&lt; has toker reached the end of its stream? &gt;-------------------</span>

bool Toker::canRead() { return pConsumer-&gt;canRead(); }

<span class = "toggleCommentDisplay">//----&lt; start/stop returning comments as tokens &gt;--------------------</span>

void Toker::returnComments(bool doReturnComments)
{
  pConsumer-&gt;returnComments(doReturnComments);
}
<span class = "toggleCommentDisplay">//----&lt; is this token a comment? &gt;-----------------------------------</span>

bool Toker::isComment(const std::string& tok)
{
  if (tok.find("<span class = "toggleCommentDisplay">//") &lt; tok.size() || tok.find("/*") &lt; tok.size())</span>
    return true;
  return false;
}
<span class = "toggleCommentDisplay">//----&lt; return number of newlines pulled from stream &gt;---------------</span>

size_t Toker::currentLineCount()
{
  return pConsumer-&gt;currentLineCount();
}
<span class = "toggleCommentDisplay">//----&lt; set one and two char tokens &gt;--------------------------------</span>

void Toker::setSpecialTokens(const std::string& commaSeparatedTokens)
{
  pConsumer-&gt;setSpecialTokens(commaSeparatedTokens);
}
<span class = "toggleCommentDisplay">//----&lt; debugging output to console if TEST_LOG is #defined &gt;--------</span>

void testLog(const std::string& msg)
{
#ifdef TEST_LOG
  std::cout &lt;&lt; "\n  " &lt;&lt; msg;
#endif
}

<span class = "toggleCommentDisplay">//----&lt; test stub &gt;--------------------------------------------------</span>

using Helper = Utilities::StringHelper;
using namespace Utilities;

#ifdef TEST_TOKENIZER

#include &lt;fstream&gt;
#include &lt;exception&gt;


int main()
{
  Helper::Title("Testing Tokenizer");

  <span class = "toggleCommentDisplay">//std::string fileSpec = "../Tokenizer/Tokenizer.cpp";</span>
  <span class = "toggleCommentDisplay">//std::string fileSpec = "../Tokenizer/Tokenizer.h";</span>
  std::string fileSpec = "../Tokenizer/Test.txt";
  <span class = "toggleCommentDisplay">//std::string fileSpec = "../SemiExp/SemiExp.h";</span>
  try
  {
    std::ifstream in(fileSpec);
    if (!in.good())
    {
      std::cout &lt;&lt; "\n  can't open " &lt;&lt; fileSpec &lt;&lt; "\n\n";
      return 1;
    }

    {
      Toker toker;
      toker.returnComments();
      toker.attach(&in);
      std::cout &lt;&lt; "\n  current line count = " &lt;&lt; toker.currentLineCount();
      do
      {
        std::string tok = toker.getTok();
        if (tok == "\n")
          tok = "newline";
        std::cout &lt;&lt; "\n -- " &lt;&lt; tok;
      } while (in.good());
      std::cout &lt;&lt; "\n  current line count = " &lt;&lt; toker.currentLineCount();
    }
 
    putline();
    Helper::title("Testing change of special characters");
    std::string newSpecialChars = "., :, +, +=, \n { }";

    Toker toker;
    toker.returnComments();
    toker.setSpecialTokens(newSpecialChars);
    in.clear();

    in.seekg(std::ios::beg);
    toker.attach(&in);
    std::cout &lt;&lt; "\n  new special tokens: " &lt;&lt; newSpecialChars;
    do
    {
      std::string tok = toker.getTok();
      if (tok == "\n")
        tok = "newline";
      std::cout &lt;&lt; "\n -- " &lt;&lt; tok;
    } while (in.good());
    std::cout &lt;&lt; "\n  current line count = " &lt;&lt; toker.currentLineCount() &lt;&lt; "\n";

    <span class = "toggleCommentDisplay">//Helper::title("Testing re-attach:");</span>
    <span class = "toggleCommentDisplay">//std::string path = "../Tokenizer/Tokenizer.h";</span>
    <span class = "toggleCommentDisplay">//std::ifstream inAgain(path);</span>
    <span class = "toggleCommentDisplay">//if (inAgain.good())</span>
    <span class = "toggleCommentDisplay">//{</span>
    <span class = "toggleCommentDisplay">//  toker.attach(&inAgain);</span>
    <span class = "toggleCommentDisplay">//  do</span>
    <span class = "toggleCommentDisplay">//  {</span>
    <span class = "toggleCommentDisplay">//    std::string tok = toker.getTok();</span>
    <span class = "toggleCommentDisplay">//    if (tok == "\n")</span>
    <span class = "toggleCommentDisplay">//      tok = "newline";</span>
    <span class = "toggleCommentDisplay">//    std::cout &lt;&lt; "\n -- " &lt;&lt; tok;</span>
    <span class = "toggleCommentDisplay">//  } while (inAgain.good());</span>
    <span class = "toggleCommentDisplay">//  std::cout &lt;&lt; "\n  current line count = " &lt;&lt; toker.currentLineCount();</span>
    <span class = "toggleCommentDisplay">//}</span>
    <span class = "toggleCommentDisplay">//else</span>
    <span class = "toggleCommentDisplay">//{</span>
    <span class = "toggleCommentDisplay">//  std::cout &lt;&lt; "\n  can't attach to " &lt;&lt; path &lt;&lt; "\n";</span>
    <span class = "toggleCommentDisplay">//}</span>
  }
  catch (std::logic_error& ex)
  {
    std::cout &lt;&lt; "\n  " &lt;&lt; ex.what();
  }
  std::cout &lt;&lt; "\n\n";
  return 0;
}
#endif

</pre>
</body></html>
